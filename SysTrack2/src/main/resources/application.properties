# App
spring.application.name=SysTrack2

# Porta: usa $PORT do Azure (fallback 8080 local)
server.port=${PORT:8080}

# Respeitar X-Forwarded-* do App Service (URLs corretas atrás do proxy)
server.forward-headers-strategy=framework

# ===================== DataSource (Azure SQL via ENV VARS) =====================
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver

# Pool Hikari (ajuste conforme o plano do App Service)
spring.datasource.hikari.maximum-pool-size=${DB_MAX_POOL_SIZE:10}
spring.datasource.hikari.minimum-idle=${DB_MIN_IDLE:2}
spring.datasource.hikari.connection-timeout=${DB_CONNECTION_TIMEOUT_MS:30000}
spring.datasource.hikari.validation-timeout=${DB_VALIDATION_TIMEOUT_MS:5000}

# ===================== JPA/Hibernate =====================
spring.jpa.show-sql=${JPA_SHOW_SQL:false}
spring.jpa.open-in-view=false
spring.jpa.hibernate.ddl-auto=none
# Dialeto explícito (Hibernate 6)
spring.jpa.database-platform=org.hibernate.dialect.SQLServerDialect

# ===================== Flyway =====================
# Habilite via env var quando tiver migrações T-SQL compatíveis
spring.flyway.enabled=${FLYWAY_ENABLED:false}
spring.flyway.locations=${FLYWAY_LOCATIONS:classpath:db/migration}
spring.flyway.baseline-on-migrate=${FLYWAY_BASELINE_ON_MIGRATE:true}

# ===================== Logging =====================
# Loga em STDOUT (o App Service capta)
logging.file.name=
logging.pattern.level=%5p
